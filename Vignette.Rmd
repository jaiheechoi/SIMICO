---
title: "SIMICO Vignette"
author: "Vignette Author"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
There are three steps to running the multiple outcome test with this package:

First, generate the left and right time intervals \textbf{for each outcome}, as well as the left and right indices. 
xMat is the n*p matrix of non-genetic covariates (not including an intercept)
lt is the n*1 vector of times for the left side of the interval. If an observation is left-censored, you can just put in 0.
rt is the n*1 vector of times for the right side of the interval. If an observation is right-censored, you can put in Inf or any numeric value.
obs_ind is the n*1 indicator vector for whether the observation is right-censored. If so, there should be a 0, otherwise there should be a 1.
tpos_ind is the n*1 indicator vector of whether the observation is left-censored. If so, there should be a 0, otherwise there should be 1.
quant_r can be used to pass in knot locations for the spline, we suggest not specifying this and letting the package work automatically.
nKnots is a scalar number of interior knots. The default of 1 will create three total knots, one interior and two endpoint knots.
Next you need to fit the null model. You only need to do this once for all SNP-sets to be tested. The call is ICSKAT_fit_null(), and you need the following arguments:
init_beta is a vector holding the initial guess at the covariates for each column in the design matrices generated by make_IC_dmat(). The number of elements should be equal to the number of columns in the design matrices. Usually you can just initialize it to a vector of 0s or 1s. If you happen to have a good idea of what the coefficients are, then this will speed up convergence.
left_dmat is output directly from make_IC_dmat().
right_dmat is output directly from make_IC_dmat
obs_ind, tpos_ind, lt, and rt have been covered above.
Finally, call ICskat() for each set of SNPs that you want to test. The gMat argument should be the n*q matrix of genotypes. You will also need left_dmat, right_dmat, lt, rt, obs_ind, and tpos_ind, which have been covered above. Finally, you will need null_beta and Itt, which come directly from ICSKAT_fit_null, see below for an example. You can also call ICSKATO() to run the ICSKATO test. This function takes the output form ICskat() as the only argument.

```{r download, eval = F}
devtools::install_github("jaiheechoi/SIMICO")
library(SIMICO)
```
Worked Example:

Suppose we are interested in testing whether a specific gene is associated with two different correlated outcomes: time until a fall and time until a fracture. We will simulate event times for 10,000 subjects under a proportional hazards model with baseline cumulative hazard function H(t)=t. We will set four observations times at times 1, 2, 3, and 4. Each subject will have a 10% chance of missing any given visit. The genetic data set will consist of 50 SNPs in the gene of interest. We will use 100 quadrature nodes as well as : The subject specific random effect will be drawn from a N(0,1) distribution. The genetic matrices were generated to have mean parameters uniformly distributed between (0.01, 0.05) and common pairwise correlation of 0.1. We simulated two fixed covariates--one generated from a N(0,2) and the other from a Binomaial(0.5). 

Example with two outcomes
```{r k2, echo=TRUE}
library(SIMICO)

# Set three outcomes
k = 2

# Set number of observations
n = 1500

# Set number of covariates
p = 2

# Set number of SNPs
q = 50

# Set number of quadrature nodes
d = 100

# Variance of subject-specific random effect
tauSq = 1

# Pairwise correlation
rho = 0.1

# Define the effect sizes
effectSizes <- c(.03, .15)

# the baseline cumulative hazard function
bhFunInv <- function(x) {x}

set.seed(1)
# Fixed effects
xMat <- cbind(rnorm(n), rbinom(n=n, size=1, prob=0.5))

# Genetic effects
gMat <- sim_gmat(n, q, rho)

# True model has nothing
fixedMat <- matrix(data=0, nrow=n, ncol=k)

# Generate the multiple outcomes
exampleDat <- simico_gen_dat(bhFunInv = bhFunInv, obsTimes = 1:3, windowHalf = 0.1, n, p, k, tauSq, gMat, effectSizes)

# Set the initial estimate values
init_beta <-c (rep(c(0, 0, 0, 1, 0), k), 1)

# Run the newton-raphson
nullFit <- simico_fit_null(init_beta = init_beta, epsilon = 10^-5, xDats = exampleDat$sample$xDats, lt_all = exampleDat$leftTimesMat, rt_all = exampleDat$rightTimesMat, k = k, d = d)

# Get the test statistics p-values
out <- simico_out(nullFit = nullFit$beta_fit, xDats = exampleDat$sample$xDats, lt_all = exampleDat$leftTimesMat, rt_all = exampleDat$rightTimesMat, Itt = nullFit$jmat, a1 = 1, a2 = 25, G = gMat, k  = k, d = d)

# Print results
# Score statistic
out$multQ

# P-values
out$multP
```


Example with five outcomes
```{r k5, echo=TRUE, eval = TRUE}

# Set three outcomes
k = 5

# Set number of observations
n = 5000

# Set number of covariates
p = 4

# Set number of SNPs
q = 50

# Set number of quadrature nodes
d = 100

# Variance of subject-specific random effect
tausq = 1

# Define the effect sizes
effectSizes <- c(.03, .15, .3, .075, .1)

# the baseline cumulative hazard function
bhFunInv <- function(x) {x}

set.seed(1)
# Fixed effects
xMat <- cbind(rnorm(n), rbinom(n=n, size=1, prob=0.5))

# Genetic effects
gMat <- sim_gmat(n, q, rho)

# True model has nothing
fixedMat <- matrix(data=0, nrow=n, ncol=k)

# Generate the multiple outcomes
exampleDat <- newgen(bhFunInv = bhFunInv, obsTimes = 1:3, windowHalf = 0.1, n, p, k, tauSq, gMat, effectSizes)

# Set the initial estimate values
init_beta <-c (rep(c(0, 0, 0, 1, 0), k), 1)

# Run the newton-raphson
nullFit <- simico_fit_null(init_beta = init_beta, epsilon = 10^-5, xDats = exampleDat$sample$xDats, lt_all = exampleDat$leftTimesMat, rt_all = exampleDat$rightTimesMat, k = k, d = d)

# Get the test statistics p-values
out <- simico_out(nullFit = nullFit$beta_fit, xDats = exampleDat$sample$xDats, lt_all = exampleDat$leftTimesMat, rt_all = exampleDat$rightTimesMat, Itt = nullFit$jmat, a1 = 1, a2 = 25, G = gMat, k  = k, d = d)

# Print results
# Score statistic
out$multQ

# P-values
out$multP
```
